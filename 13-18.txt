13页。
这些标识符用于确定对象上的所有操作和授权。
	在整个系统调用实例中, 我们假定在同一变量中使用的对象具有相同的授权要求。为了模拟这一点, 我们使用了第一个受控操作, 其中对象显示为标识符。如果首先在同一受控操作中访问两个对象, 则必须将其分配给同一变量 (因为该变量在两个受控操作中是相同的)。但是, 不同的执行路径可能会导致首先在不同的受控操作中使用相同的变量。但是, 具有相同授权要求的类的聚合将合并这些情况, 因此这一假设已被证明是有效的。
	系统调用参数几乎在每次调用时都会更改, 但只有少数参数真正影响授权 (例如, 打开时的访问标志)。因此, 我们收集参数, 但只使用我们发现有影响的授权要求来进行分区的参数。我们检查过的系统调用中只有少数基于其输入参数的授权, 如开放、ioctl 和 fcntl。由于根据不同的输入使用不同的授权, 因此这些系统调用更为复杂, 因此更容易出错。
4.运行时实现
	完整授权的运行时分析包括两个步骤: 内核执行日志的生成及其离线分析以确保一致性。本节介绍创建执行日志的工具的实现、用于准备和显示分析数据的日志筛选工具的实现以及我们的分析结果。
4.1.收集运行时信息
	4.1.1 日志内容。表二显示了运行时分析期间收集的信息。受控制的操作由元组标识 (指令指针、对象类型、成员、访问)。将受控操作 id 分配给每个唯一组合。授权由 (lsm 钩子、策略操作) 唯一标识。与受控操作一样, 为每个操作分配了唯一的授权 id。函数入口和出口也会被记录。函数项地址唯一标识函数。
	对于执行的每个受控操作或授权, 日志必须包含所涉及对象的标识 (例如 inode)。对象实体 (oid) 是根据对象类型定义的, 例如, inodes 是由设备 id 标识的,节点内的编号, 而任务则由进程 id 标识。oid 在上下文中只需要是唯一的。
	我们使用上下文的概念来表示内核事件的处理 (例如, 系统调用)。授权显然仅在执行它们的上下文中有效, 因此, 日志条目还必须包括受控操作和授权的上下文。
	4.1.2 集合概述。图3显示了该工具的概述。日志的创建涉及三个阶段: 必须生成所需的信息, 必须收集这些信息, 并且必须将其写入日志。
	信息是以三种不同的方式生成的。首先, 授权信息由 lsm 挂钩生成。其次, 通过使用 gcc 的修改版本编译内核来生成受控操作的控制操作详细信息, 并在所有此类操作之前使用对处理程序函数的调用来处理内核。通过在编译时检测内核, 也会生成控制流信息。第三, 上下文信息是通过在内核中放置断点生成的。以下各节将更详细地讨论这三种方法。
	第四, 加载内核模块以接收图3所示的信息。这些模块执行粗粒度筛选, 并将信息排列为正确的格式, 然后再将记录传递到日志记录模块。日志记录模块将上下文 id 分配给传入记录, 并将信息写入缓冲区。
	4.1.3 授权信息。lsm 修补程序已经提供了日志授权信息, 因此几乎不需要额外的实现。授权筛选器只是一个 lsm 模块, 它为每个授权添加一个日志条目。这些日志条目标识已执行的授权（例如，RMDIR PARENT、RMDIR TARGET）和授权的对象。
	4.1.4受控操作。为了记录受控操作，我们首先必须在内核中定位受控操作，然后提供用于检测这些操作的执行的机制。
	识别内核中的受控操作需要源分析。我们选择通过分析GCC的中间树表示来识别受控操作，而不是直接进行源代码分析（这很困难）。由于Linux依赖于GCC扩展，所以源代码分析需要使用GCC解析器，因此利用它已经构建的树似乎是合乎逻辑的。为了识别受控操作，我们遍历树寻找访问中介数据类型的成员的表达式。2当检测到受控操作时，我们在表达式存在的语句之前插入对包含对象、类型、成员和访问的function_control_op的调用。如果表达式是循环的条件语句，则在循环之前和每次迭代结束时插入调用。此调用包含标识受控操作并允许处理程序提取对象标识所需的所有信息。
	一些访问会导致此方法的问题。首先，可以通过获取成员的地址、将其存储到指针并通过指针更改成员来修改结构成员。由于初始访问是对指针变量的读取，因此我们可能会错过后续的写入。我们不是执行更广泛的源分析来识别这些情况，而是简单地检测何时出现混淆。第二，当受控数据结构被转换为非受控t时，我们也可能错过对受控数据结构的访问。YPE。这也被检测到。我们的初步分析表明，这些情况以少量（虽然是第一次，但次数很多）的方式发生，因此它们可以作为特殊情况处理。
	4.1.5控制流程。控制流信息是通过使用GCC-3.0提供的finstrument-functions开关编译内核生成的。此选项使编译器在每个函数的入口和出口插入对处理程序函数的调用。这些处理程序函数然后将信息传递给适当的模块。
	4.1.6上下文信息。由于内核中随时可能存在多个执行上下文，所以所有日志条目都必须包含上下文ID，因此分析可以判断哪些条目彼此相关。不幸的是，没有可用的唯一标识单个执行上下文的密钥，我们必须选择非唯一密钥，并设计一种方法来区分具有相同密钥的上下文。
	我们选择当前内核堆栈的底部作为非唯一密钥，因为我们需要一个至少是并发活动执行中唯一的密钥，并且该属性对于堆栈来说似乎不可能被违反。尽管内核堆栈在并发活动执行中是唯一的，但是由于三个原因，每个上下文内核堆栈都不是唯一的：来自同一进程的所有系统调用都使用相同的内核堆栈，一旦进程死亡，内核堆栈可能重新分配给新进程，并且用它们中断的进程的内核堆栈来执行中断。这里的关键特性是，尽管上下文键不是唯一的，但是具有相同键的上下文从不交错。因此，通过记录上下文的开始和结束（以及相关的键），我们可以明确地向上下文分配日志条目。
	幸运的是，只有少数几个点可以开始上下文（全部位于entry.S中），并且上下文可以结束的位置数量大致相等。退出系统调用是一个例外情况，因为它从不返回，因此，do_exit()中的schedule()调用也被标识为上下文退出点。由于入口/出口点的数量是可管理的，因此我们为每个内核版本手动标识它们的位置，并在运行时自动插入它们。为了在运行时收集此信息，上下文过滤器在所有入口和出口点将断点指令插入内核的（内存映像）中。当执行断点时，上下文过滤器创建包含上下文键的日志条目，以及这是上下文的开始还是结束。
	4.1.7性能。我们做了一个简单的性能检查以确定仪表化内核中的性能下降。在未修改的Linux内核上，LMBench用于“快速基准测试”花费了3分钟4秒。仪器内核直径3min24μm，退化率略高于10%。我们认为，这种开销对于深入分析来说是可以接受的。回想一下，内核用于分析，并且以后使用内核不需要挂钩。
	除此之外，我们在20个系统调用中抽取了1个。这是为了保持日志增长率低于磁盘吞吐率。由于这些基准测试多次执行相同的系统调用，因此我们没有注意到“丢失”任何与安全相关的信息。如果必要，可以设计用于确定何时删除日志条目的策略。
4.2日志分析
	我们还构建了一个工具，能够进行日志分析，以识别授权需求中的一致性，如3.2节所述。该工具能够指定用于提取所需日志条目的规则，称为日志-过滤规则，并根据提取的条目计算授权一致性。我们以两种方式显示一致性结果：（1）表示每个授权和控制操作之间的一致性的授权图和（2）表示通过授权和一致性级别聚合的受控操作的一致性类列表。

	4.2.1日志筛选规则。日志过滤工具以执行日志和一组过滤规则作为输入，并输出匹配规则的日志条目。规则语言目前水平相当低，因为我们更关心的是证明其可行性，以及创建良好的高级规则语言。然而，我们演示了规则语言，以了解可能的分析类型。
	规则库由一组定义匹配需求的规则定义。规则包括（1）索引；（2）依赖项规范；（3）一组语句。索引标识规则库中的规则。依赖关系通过索引声明与其他规则的关系。我们可以声明一个规则只能匹配另一个规则（D，i）也匹配的条目，其中i是另一个规则的索引。此外，我们可以声明一个规则不包括由另一个规则i匹配的条目的依赖性，如(N，i)。最后，语句描述条目的匹配条件。通过识别条目类型（id类型），然后匹配类型-specic级别，可以对这些进行指定。条目类型包括：事件（CONTEXT）、授权（SEC_CHK）、函数（FUNC）和受控操作（CNTL_OP）。
	图4显示了一些示例规则。路径一致性规则在运行指定地址的受控操作时，将读取系统调用上下文中的所有授权。rst行收集读取系统调用（即系统调用的开始）的所有上下文条目。第二行收集指定位置上受控操作的所有条目。(D,1)表示该语句依赖于语句1，因此将只收集读取系统调用上下文中的条目。第三行收集读取系统调用上下文中的所有授权。在这种情况下，此受控操作的每次执行都应该具有相同的授权，或者存在违反路径不一致性不变量的情况，该路径不一致性不变量禁止受控操作具有多组合法授权。
	函数一致性规则在读系统调用上下文中收集“读 节点成员”的所有授权和受控操作。在第二行上指定(D,1)意味着将提取读系统调用中此类型的所有受控操作。如果与此受控操作关联的授权不相同，则成员访问与其位置一致。
	系统调用输入一致规则收集每个打开的系统调用中的所有日志条目，以便进行只读访问。打开的系统调用的授权依赖于文件被打开的访问，所以打开是系统调用输入一致的。此外，我们还在这个规则中显示了一个负面过滤器，它消除了path_walk函数范围内的所有条目。文件查找的授权，包括任何链接遍历，可以与授权打开该文件的授权分开。这种过滤功能使我们能够灵活地选择分析范围。
	所面临的挑战是编写日志过滤规则，以表示可以执行有意义的分析的情况。通常，我们希望日志过滤规则描述这样一种情况:结果符合我们的期望的一致性类。我们发现，一个乐观的一致性初始假设，然后进行细化，对于设计这样的规则是有效的。
	我们从假设所有受控操作的最高级别一致性开始，系统调用一致性。如果系统调用执行中的所有受控操作具有相同的授权(即，则我们只需验证授权是否正确即可。如果没有，我们将检查是否可以在下一个一致性级别(系统调用输入)上编写规则。如果输入没有可识别的效果，或者无法解决与我们期望的一致性(即。然后我们进入下一个层次，数据类型一致性，等等。通常，在不更改规则的情况下，有效的分析可以降低一致性级别。我们只需要一种方法来查看具有相同一致性级别的聚合，例如在数据类型一致的情况下，将每种数据类型映射到其授权。我们使用一致性类列表来查看多个一致性类(参见4.2.3节)。
	4.2.2图形化日志分析。分析工具还可以生成图形，以支持对经过过滤的数据进行可视化分析。使用这些图，可以通过检查验证授权一致性，如下所述。授权图由过滤后的日志中的两组节点组成:(1)受控操作和(2)所做的授权。从每个受控制的操作到运行时已满足的授权，都要绘制边缘。有两种类型的边:(1)总是边表示每次运行受控操作时都满足关联授权;(2)有时边表示在运行受控操作时至少满足一次关联授权。
	始终边缘(以及缺少边缘)意味着授权与低层不一致。有时边表示不一致。如果缺少预期的边缘，则表示缺少授权。
	图5显示了一个授权图示例。示例图使用dotty图形可视化工具[Koutsofios和North]显示。在本例中，授权图显示了两种类型的fcntl调用的受控操作和授权:(1)fcntl(fd, F_SETOWN, pid_owner)和(2)fcntl(fd, F_SETLEASE,F_UNLCK)

